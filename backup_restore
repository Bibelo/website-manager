#!/bin/bash
# This script configures the developers group depending on the type of server
# It then connects as each users, so that homes are created
# Finally, it sets the developers group as primary group for each user
# 
# Version 1.0
# tbartolone 30/06/2020
 set -x

usage() {
	init
	PROGNAME=$0
	cat <<- EOF

	Missing arguments
	$PROGNAME <archive full path> <original project name> <new project name> <mode>

	- suffix: project will be restored to <project>-<suffix>
		- if empty, project will be restored simply to <project>
	
	<mode> : dev or prod

	EOF
	clearmsg "\nList of archives in $backups_path"
	for file in $(ls -1Atr $backups_path); do
		readlink -m $backups_path/$file
	done
	exit 1
}

init(){
	GREEN='\033[0;32m'
	RED='\033[0;31m'
	CYAN='\033[0;36m'
	NC='\033[0m' # No Color
	timestamp=$(date +%Y%m%H%M)

	. config.ini
}

clearmsg(){
        msg=$1
        printf "${CYAN}${msg}${NC}\n"
}

go(){
	:
}

testexec(){
	:
}

generaldb_credential(){
    unset login
    prompt="Enter generaldb_mariadb admin username: "
    read -p "$prompt" username

    unset password
    prompt="Enter generaldb_mariadb admin password: "
    while IFS= read -p "$prompt" -r -s -n 1 char
    do
        if [[ $char == $'\0' ]]
        then
            break
        fi
        prompt='*'
        password+="$char"
    done
    echo
}

# generate_new_credentials(){
# export new_username=$project$suffix-$(bw generate -p)
# export new_password=$(bw generate)
# }

input_credentials(){
	echo "Enter project username for the DB"
	read new_username
	echo "Enter project password for the DB"
	read new_password
	export new_username
	export new_password
}

generaldb_credentials_file(){
        mode=$1
        unset username
        unset password
        if [[ ! -f .${mode}_generaldb_creds ]]; then
                echo "Credentials file cannot be found (.generaldb_creds)"
                exit 1
        fi

        . ./.${mode}_generaldb_creds

        username=${mode}_username
        username=${!username}
        password=${mode}_password
        password=${!password}

        if [[ -z $username ]] || [[ -z password ]]; then
                echo "Credentials are empty (in .generaldb_creds)"
                exit 1
        fi
}


create_db_user(){
        command="CREATE DATABASE \`$project$suffix\`; SHOW DATABASES; CREATE USER \"$new_username\" IDENTIFIED BY \"$new_password\"; SELECT User FROM mysql.user; GRANT ALL PRIVILEGES ON \`$project$suffix\`.* TO \"$new_username\"; FLUSH PRIVILEGES; SHOW GRANTS FOR \"$new_username\";"

        docker exec -it $generaldb_container_name mysql -u "$username" -p$password -e"$command"
}

main(){

	init

	archive=$1
	original_name_mode=$2
	mode=${@: -1}

	if [[ $# -eq 4 ]]; then
		new_name=$3
		new_name_mode=${new_name}-${mode}
	else
		new_name=''
	fi

	# Checks
	if [[ -n $new_name ]]; then
		if [[ -d $varwww_path/$new_name_mode ]]; then
			clearmsg "There's already a project $new_name in $mode mode, in $varwww_path/$new_name_mode"
			echo "Maybe it's just a brand new empty project you've just created for this restoration"
			echo "In this case, you can just proceed by pressing a key"
			read
		else
			clearmsg "First please create project $new_name in $mode mode"
			read
		fi
	else
		if [[ -d $varwww_path/$original_name_mode ]]; then
			clearmsg "There's already a project original_name_mode, in $varwww_path/$original_name_mode"
			exit 1
		fi
	fi

	archive_name=$(basename $archive | sed 's/\.tgz//')
	mkdir -p $restore_path/$archive_name
	tar -xzf $archive --directory $restore_path/$archive_name

	# RESTORE DATA IN /var/www
	# If there's new name, means we don't overwrite the existing project with the original name
	if [[ -n $new_name ]]; then
		# Restore data
		# we cannot delete and just copy the wordpress folder
		# as we need to keep wordpress/wp-config.php
		rm -rf $varwww_path/$new_name_mode/wordpress/wp-content
		mv $restore_path/$archive_name/$relative_varwww_path/$original_name_mode/wordpress/wp-content $varwww_path/$new_name_mode/wordpress/
	else
		# Restore data
		# In the case where we just restore the project, it is same wordpress folder
		mv $restore_path/$archive_name/$relative_varwww_path/$original_name_mode $varwww_path/$original_name_mode
	fi

#	if [[ -n $new_name ]]; then
#		clearmsg "Recreating $new_name_mode container"
#		docker-compose -f $project_path/$new_name_mode/docker-compose.yml up -d
#	fi
	exit
	clearmsg "mode $archive project $project"

	generaldb_credentials_file $mode
	clearmsg "$username $password"

	# RESTORE CONTAINER CONFIG
#	mv $restore_path/$archive_name/$relative_project_path/$project $project_path/$project$suffix
#	sed -i "s/$project/$project$suffix/g" $project_path/$project$suffix/docker-compose.yml

	# Restore base
	echo -e "\nRestoring base"
	set +x
	generaldb_credential
	input_credentials
	create_db_user
	set -x
	mv $restore_path/$archive_name/$relative_db_shared_path_host/$project.sql $db_shared_path_host
#        command="CREATE DATABASE \`$project$suffix\`; SHOW DATABASES; CREATE USER \"$new_username\" IDENTIFIED BY \"$new_password\"; SELECT User FROM mysql.user; GRANT ALL PRIVILEGES ON \`$project$suffix\`.* TO \"$new_username\"; FLUSH PRIVILEGES; SHOW GRANTS FOR \"$new_username\";"
        docker exec $generaldb_container_name bash -c "mysql -u $username -p$password $project$suffix < $db_shared_path_container/$project.sql"

#	generate_new_credentials

        echo -e "\nSave this info (in Bitwarden?):"
        echo "New database: $new_project"
        echo "New user: $new_username"
        echo "New password: $new_password"

        echo "When recreating the project container, you will need to type this line before:"
        echo "export new_project=$project$suffix; export new_username=$new_username; export new_password=$new_password"
        echo "Then:"
        echo "docker compose -f /projects/$project$suffix/docker-compose.yml up -d"



	exit

	if [[ $1 = "go" ]]
		then
			init
			go
			testexec
		else
			init
			testexec
	fi
}

if [[ $# -eq 0 ]]
	then
		usage
fi

main $@
